class t{ontext=null;constructor(t=/\r?\n/,e=!1){this._eol=t,this._skip=e}reset(){this._buf=""}write(t){if(!this.ontext)return;this._buf+=t;let e=this._buf.split(this._eol);1!=e.length&&(e[e.length-1].length?this._buf=e.pop():(this._buf="",e.pop()),this._skip&&(e.shift(),this._skip=!1),e.forEach(t=>this.ontext(t)))}_buf=""}class e{onbin=null;ontext=null;online=null;async onopen(){}async onclose(){}async onerror(t){}async onportchange(t){}constructor(){this.splitter=new t,this.splitter.ontext=t=>this.online(t),this._ok="serial"in navigator,this._ok?this._update().then(()=>this.onportchange(this.selected())):this._error("Browser is not supported")}opened(){return this._open}selected(){return!!this._port}getName(){if(!this._port)return"None";switch(this._port.getInfo().usbProductId){case 21971:return"CH343";case 30084:return"CH340S";case 29986:case 29987:return"CH340";case 21778:case 21795:case 21892:return"CH341";case 1026:case 1027:case 1028:case 1029:case 24577:case 1538:case 24592:return"FT232";case 38144:case 258:case 1281:case 32937:case 6e4:case 60001:case 60003:return"CP210x"}return"Unknown"}async select(){if(this._ok){try{await this.close();let t=await navigator.serial.getPorts();for(let e of t)await e.forget();await new Promise(t=>setTimeout(t,50)),await navigator.serial.requestPort(),await this._update()}catch(t){this._port=null,this._error(t)}this.onportchange(this.selected())}}async open(t=115200){if(this._ok)try{if(await this.close(),await this._update(),!this.selected())throw"No port";try{await this._port.open({baudRate:t}),this._open=!0,this.onopen(),await this._readLoop()}finally{await this._port.close(),this._open=!1,this.onclose()}}catch(t){this._error(t)}}async close(){if(!this._ok)return;if(!this._open)return;this._close=!0,this._reader&&await this._reader.cancel();const t=performance.now();for(;this._open;)performance.now()-t>2e3&&this._error("Close timeout"),await new Promise(t=>setTimeout(t,10))}async sendBin(t){if(this._ok&&this.opened())try{let e=this._port.writable.getWriter();await e.write(t),e.releaseLock()}catch(t){this._error(t)}}async sendText(t){await this.sendBin((new TextEncoder).encode(t))}_port=null;_open=!1;_close=!1;_reader=null;_error(t){this.onerror("[SerialJS] "+t)}async _update(){let t=await navigator.serial.getPorts();this._port=t.length?t[0]:null}async _readLoop(){this._close=!1;const t=new TextDecoder;for(;this._port.readable&&!this._close;){this._reader=this._port.readable.getReader();try{for(;;){const{done:e,value:s}=await this._reader.read();if(e)return;if(this.onbin&&this.onbin(s),this.ontext||this.online){const e=t.decode(s);this.ontext&&this.ontext(e),this.online&&this.splitter.write(e)}}}finally{this._reader.releaseLock(),this._reader=null}}}}export{e as default};